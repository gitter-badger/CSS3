%YAML 1.2
---
name: CSS3
file_extensions: [css, css.erb]
scope: source.css

variables:
  an_plus_b: '[+-]?\d*n(?:\s*[+-]\s*\d+)?'
  angle_unit: turn|grad|rad|deg
  arithmetic_operator: '[-+*/]'
  attr_matcher: '[~^$*|]?='
  # \b word boundaries are not enough to prevent some mismatches, like "clip\b"
  # matching "clip-path". adding negative lookahead for dashes fixes this.
  b: '\b{{not_followed_by_dash}}'
  column: '\|\|'
  combinator: '(?:{{column}}|>{1,3}|[+~])'
  custom_property_name: '--{{identifier}}'
  escape: '\\(?:[^\n\r\f\h]|\h{1,6}{{whitespace}}?)'
  exponent: '[eE][+-]?\d+'
  frequency_unit: k?Hz
  ident_char: '[-a-zA-Z\d_\\\p{^ASCII}]'
  ident_start: '-?[a-zA-Z_\\\p{^ASCII}]'
  identifier: '{{ident_start}}{{ident_char}}*'
  integer: '[+-]?\d+'
  integer_non_neg: \+?\d+
  integer_pos: '\+?(?:[1-9]\d+|[1-9])'
  integer_zero_to_255: '\b(?:2[0-5][0-5]|1\d\d|[1-9]\d|\d)\b'
  length_unit: r?em|ex|ch|vw|vh|vmin|vmax|cm|mm|q|in|pc|pt|px
  not_followed_by_dash: '(?!-)'
  ns_prefix: '(?:{{identifier}}|(\*))?(\|)'
  number: '[+-]?(?:\d+\.\d+|\.\d+|\d+)(?:{{exponent}})?'
  number_non_neg: '\+?(?:\d+\.\d+|\.\d+|\d+)(?:{{exponent}})?'
  number_pos: '\+?(?:\d+\.\d*[1-9]\d*|\.\d*[1-9]\d*|[1-9]\d*)(?:{{exponent}})?'
  # number_zero_to_one: \b0(?:\.\d+)?|1(?:\.0+)?|\.\d+  # TODO: delete this if the other one works
  number_zero_to_one: '\+?(?:1\.0+|0?\.\d+|[01])'
  number_zero_to_100: '\b(?:100|[1-9]\d|\d)(?:\.\d+)?|\.\d+'
  optional_min_max_prefix: '\b(?:min-|max-)?'
  optional_vendor_prefix: '(?:-webkit-|-ms-|-moz-)?'
  percentage_unit: '%'
  ratio: '({{integer_pos}})\s*(\/)\s*({{integer_pos}})'
  resolution_unit: dppx|dpi|dpcm
  time_unit: m?s
  # '' is how you escape a single ' in YAML
  url_char: '[a-zA-Z0-9\-\._~:/\?#\[\]''@!$&()\*\+\%,;=]'
  whitespace: '[ \t\n]'
  wq_name: '({{ns_prefix}})?({{identifier}}|(\*))'
  zero: \b0\b

contexts:
  main:
    - include: at-media
    - include: rule

  angle:
    - include: func-calc
    - match: '(?x)
        (?:
          ({{number}})({{angle_unit}})\b|
          ({{zero}})
        )'
      captures:
        1: constant.numeric.css
        2: keyword.other.unit.css
        3: constant.numeric.css

  any-value:
    # We don't want to try to write a regex with every possible valid value,
    # including all keywords for each property. Therefore, we try to match every
    # valid unit, numeric type, and function. Any valid identifier after that is
    # assumed to be a valid property value.
    - include: value-css-wide  # includes "var()"
    - include: func-cubic-bezier
    - include: func-steps
    # TODO: finish adding funcs here
    - include: angle
    - include: frequency
    - include: percentage
    - include: resolution
    - include: time
    - include: length
    - include: an_plus_b
    - include: integer
    - include: number
    - match: '{{identifier}}'
      scope: support.constant.property-value.css

  an_plus_b:
    - match: 'odd|even|{{an_plus_b}}'
      scope: constant.other.an-plus-b.css
    - include: integer

  arithmetic-operator:
    - match: '{{arithmetic_operator}}'
      scope: keyword.operator.arithmetic.css

  # Media queries start with "@media" and end with a closing curly brace. To
  # match this text, we define an outer scope that starts with "@media" and
  # continues until the closing "}". The text between the curlies is then
  # matched as a nested scope (the opening curly pushes a new scope on the
  # stack, which is popped at the closing curly). This lets us match the media
  # features before the opening curly and the text between the curlies in one
  # rule.
  #
  # |-------------------outer scope-----------------------------------|
  #        |---media-features-etc----||--------nested scope----------|
  # @media stuff-before-opening-curly { selector { property: value; } }
  at-media:
    - match: '(@)media{{b}}'
      captures:
        0: keyword.control.at-rule.media.css
        1: punctuation.definition.keyword.css
      push:
        - match: '}'
          scope: punctuation.section.media-query.end.css
          pop: true
        - match: '{'
          scope: punctuation.section.media-query.begin.css
          push:
            - match: '(?=})'
              pop: true
            - include: at-media
            - include: rule
        - match: '\band{{b}}'
          scope: keyword.operator.logic.media.css
        - include: media-feature
        - include: media-type
    - include: stray-brace

  baseline-position:
    - match: '\b(?:last-)?baseline{{b}}'
      scope: support.constant.property-value.css

  comment:
    - match: /\*
      push:
        - meta_scope: comment.block.css
        - match: \*/
          pop: true

  content-distribution:
    - match: '(?x)
        \b
        (?:
          stretch|
          space-evenly|
          space-between|
          space-around
        )
        {{b}}'
      scope: support.constant.property.value.css

  content-position:
    - match: '(?x)
        \b
        (?:
          start|
          right|
          left|
          flex-start|
          flex-end|
          end|
          center
        )
        {{b}}'
      scope: support.constant.property.value.css

  end-func:
    - match: \)
      scope: punctuation.section.function.end.css
      pop: true

  end-media-feature:
    - match: '(?=\))'
      pop: true

  end-value:
    # end on } if this is the last property-value pair in the block.
    # end on ) if we're inside an @supports condition.  # TODO: is this a good idea?
    - match: ';|(?=}\))'
      scope: punctuation.terminator.rule.css
      pop: true

  escape:
    - match: '{{escape}}'
      scope: constant.character.escape.css

  frequency:
    - include: func-calc
    - match: '(?x)
        (?:
          ({{number}})({{frequency_unit}})\b|
          ({{zero}})
        )'
      captures:
        1: constant.numeric.css
        2: keyword.other.unit.css
        3: constant.numeric.css

  func-calc:
    - match: \b(calc)(\()
      captures:
        1: support.function.calc.css
        2: punctuation.section.function.begin.css
      push:
        - include: end-func
        - include: length
        - include: frequency
        - include: angle
        - include: time
        - include: percentage
        - include: number
        - include: arithmetic-operator
    - include: stray-paren

  func-cubic-bezier:
    - match: \b(cubic-bezier)(\()
      captures:
        1: support.function.cubic-bezier.css
        2: punctuation.section.function.begin.css
      push:
        - include: end-func
        - include: number-zero-to-one
    - include: stray-paren

  func-steps:
    - match: \b(steps)(\()
      captures:
        1: support.function.steps.css
        2: punctuation.section.function.begin.css
      push:
        - include: end-func
        - match: '\b(?:start|end){{b}}'
        - include: integer-positive
    - include: stray-paren

  func-var:
    - match: \b(var)(\()
      captures:
        1: support.function.var.css
        2: punctuation.section.function.begin.css
      push:
        - include: end-func
        - match: ','
          push:
            - match: '(?=[,)])'
              pop: true
            - include: any-value  # <declaration-value>
        - match: '{{custom_property_name}}'
          scope: support.constant.property-name.custom.css
    - include: stray-paren

  identifier:
    - match: '{{identifier}}'
      scope: string.unquoted.identifier.css

  integer:
    - include: func-calc
    - match: '{{integer}}'
      scope: constant.numeric.css

  integer-non-negative:
    - include: func-calc
    - match: '{{integer_non_neg}}'
      scope: constant.numeric.css

  integer-positive:
    - include: func-calc
    - match: '{{integer_pos}}'
      scope: constant.numeric.css

  length:
    - include: func-calc
    - match: '(?x)
        (?:
          ({{number}})({{length_unit}})\b|
          ({{zero}})
        )'
      captures:
        1: constant.numeric.css
        2: keyword.other.unit.css
        3: constant.numeric.css

  length-non-negative:
    - include: func-calc
    - match: '(?x)
        (?:
          ({{number_non_neg}})({{length_unit}})\b|
          ({{zero}})
        )'
      captures:
        1: constant.numeric.css
        2: keyword.other.unit.css
        3: constant.numeric.css

  media-feature:
    - match: \(
      scope: punctuation.section.media-feature.begin.css
      push:
        # Note that this is different from media-feature-end, which matches
        # just before the closing paren.
        - match: \)
          scope: punctuation.section.media-feature.end.css
          pop: true
        - include: media-feature-deprecated
        - include: media-feature-custom  # TODO: correct precedence?
        - include: media-feature-aspect-ratio
        - include: media-feature-color-gamut
        - include: media-feature-grid
        - include: media-feature-hover
        - include: media-feature-inverted-colors
        - include: media-feature-monochrome-color-index
        - include: media-feature-width-height
        - include: media-feature-light-level
        - include: media-feature-orientation
        - include: media-feature-overflow-block
        - include: media-feature-overflow-inline
        - include: media-feature-pointer
        - include: media-feature-resolution
        - include: media-feature-scan
        - include: media-feature-scripting
        - include: media-feature-update
        - include: media-feature-var
        - include: media-feature-range-operator
        # Match values and comparison operators that appear at the start.
        #  |------|
        # (480px <= width <= 640px)
        - include: ratio
        - include: resolution
        - include: length-non-negative
        - include: integer-non-negative
    - include: stray-paren

  # e.g. (aspect-ratio: 16/9)
  media-feature-aspect-ratio:
    - match: '(?x)
        \b
        (
          {{optional_min_max_prefix}}
          aspect-ratio
        )\s*(:)'
      captures:
        1: support.constant.property-name.css
        2: punctuation.separator.key-value.css
      push:
        - include: end-media-feature
        - include: value-css-wide
        - include: ratio
        - include: media-feature-range-operator

  media-feature-color-gamut:
    - match: \b(color-gamut)\s*(:)
      captures:
        1: support.constant.property-name.css
        2: punctuation.separator.key-value.css
      push:
        - include: end-media-feature
        - include: value-css-wide
        - match: \b(?:srgb|rec2020|p3)\b
          scope: support.constant.property-value.css

  # TODO: finish this
  media-feature-custom:
    - match: '\-\-{{identifier}}'
      scope: support.constant.property-name.custom.css

  media-feature-deprecated:
    - match: '(?x)
        (
          {{optional_min_max_prefix}}
          device\-(?:width|height|aspect-ratio)
        )
        \s*(:)?'
      captures:
        1: support.constant.property-name.css invalid.deprecated.css
        2: punctuation.separator.key-value.css

  media-feature-grid:
    - match: \b(grid)\s*(:)?
      captures:
        1: support.constant.property-name.css
        2: punctuation.separator.key-value.css
      push:
        - include: end-media-feature
        - include: value-css-wide
        - match: \b(?:0|1)\b
          scope: support.constant.property-value.css

  media-feature-hover:
    - match: \b((?:any-)?hover)\s*(:)?
      captures:
        1: support.constant.property-name.css
        2: punctuation.separator.key-value.css
      push:
        - include: end-media-feature
        - include: value-css-wide
        - match: '\b(?:on-demand|none|hover){{b}}'
          scope: support.constant.property-value.css

  media-feature-inverted-colors:
    - match: \b(inverted-colors)\s*(:)?
      captures:
        1: support.constant.property-name.css
        2: punctuation.separator.key-value.css
      push:
        - include: end-media-feature
        - include: value-css-wide
        - match: '\b(?:none|inverted){{b}}'
          scope: support.constant.property-value.css

  media-feature-light-level:
    - match: '\b(light-level)\s*(:)'
      captures:
        1: support.constant.property-name.css
        2: punctuation.separator.key-value.css
      push:
        - include: end-media-feature
        - include: value-css-wide
        - match: washed|normal|dim
          scope: support.constant.property-value.css

  media-feature-monochrome-color-index:
    - match: '(?x)
        \b
        (
          {{optional_min_max_prefix}}
          (?:monochrome|color-index|color)
        )\s*(:)?
        {{not_followed_by_dash}}'
        # {{not_followed_by_dash}} prevents "color" from matching misspelled
        # "color-index" or "color-gamut". {{b}} won't work because ':' isn't a
        # word boundary.
      captures:
        1: support.constant.property-name.css
        2: punctuation.separator.key-value.css
      push:
        - include: end-media-feature
        - include: value-css-wide
        - include: integer-non-negative
        - include: media-feature-range-operator

  media-feature-orientation:
    - match: \b(orientation)\s*(:)
      captures:
        1: support.constant.property-name.css
        2: punctuation.separator.key-value.css
      push:
        - include: end-media-feature
        - include: value-css-wide
        - match: '\b(?:portrait|landscape){{b}}'
          scope: support.constant.property-value.css

  media-feature-overflow-block:
    - match: \b(overflow-block)\s*(:)?
      captures:
        1: support.constant.property-name.css
        2: punctuation.separator.key-value.css
      push:
        - include: end-media-feature
        - include: value-css-wide
        - match: '\b(?:scroll|paged|optional-paged|none){{b}}'
          scope: support.constant.property-value.css

  media-feature-overflow-inline:
    - match: \b(overflow-inline)\s*(:)?
      captures:
        1: support.constant.property-name.css
        2: punctuation.separator.key-value.css
      push:
        - include: end-media-feature
        - include: value-css-wide
        - match: '\b(?:scroll|none){{b}}'
          scope: support.constant.property-value.css

  media-feature-pointer:
    - match: '\b((?:any-)?pointer)\s*(:)?{{not_followed_by_dash}}'
      captures:
        1: support.constant.property-name.css
        2: punctuation.separator.key-value.css
      push:
        - include: end-media-feature
        - include: value-css-wide
        - match: '\b(?:none|fine|coarse){{b}}'
          scope: support.constant.property-value.css

  media-feature-range-operator:
    - match: '(?:[<>]=?|=)(?=[\s\w])'
      scope: keyword.operator.arithmetic.css

  # e.g. (min-resolution: 300dpi)
  media-feature-resolution:
    - match: '(?x)
        \b
        (
          {{optional_min_max_prefix}}
          resolution
        )\s*(:)?
        {{not_followed_by_dash}}'
      captures:
        1: support.constant.property-name.css
        2: punctuation.separator.key-value.css
      push:
        - include: end-media-feature
        - include: value-css-wide
        - include: resolution
        - include: media-feature-range-operator

  media-feature-scan:
    - match: '\b(scan)\s*(:)?{{not_followed_by_dash}}'
      captures:
        1: support.constant.property-name.css
        2: punctuation.separator.key-value.css
      push:
        - include: end-media-feature
        - include: value-css-wide
        - match: '\b(?:progressive|interlace){{b}}'
          scope: support.constant.property-value.css

  media-feature-scripting:
    - match: '\b(scripting)\s*(:)?{{not_followed_by_dash}}'
      captures:
        1: support.constant.property-name.css
        2: punctuation.separator.key-value.css
      push:
        - include: end-media-feature
        - include: value-css-wide
        - match: '\b(?:none|initial-only|enabled){{b}}'
          scope: support.constant.property-value.css

  media-feature-update:
    - match: '\b(update)\s*(:)?{{not_followed_by_dash}}'
      captures:
        1: support.constant.property-name.css
        2: punctuation.separator.key-value.css
      push:
        - include: end-media-feature
        - include: value-css-wide
        - match: '\b(?:normal|none|slow){{b}}'
          scope: support.constant.property-value.css

  # may appear as "(width: 480px)" or "(width >= 480px)"
  media-feature-width-height:
    - match: '(?x)
        \b
        (
          {{optional_min_max_prefix}}
          (?:width|height)
        )\s*(:)?
        {{not_followed_by_dash}}'
      captures:
        1: support.constant.property-name.css
        2: punctuation.separator.key-value.css
      push:
        - include: end-media-feature
        - include: value-css-wide
        - include: length-non-negative
        - include: media-feature-range-operator

  media-type:
    - include: media-type-deprecated
    - match: (?:(only|not)\s+)?(speech|screen|print|all)
      captures:
        1: keyword.operator.logic.media.css
        2: support.constant.media.css

  media-type-deprecated:
    - match: '\b(?:tv|tty|reader|projection|handheld|embossed|braille|aural){{b}}'
      scope: support.constant.media.css invalid.deprecated.css

  number:
    - include: func-calc
    - match: '{{number}}'
      scope: constant.numeric.css

  number-zero-to-one:
    - include: func-calc
    - match: '{{number_zero_to_one}}'
      scope: constant.numeric.css

  overflow-position:
    - match: '\b(?:un)?safe{{b}}'
      scope: support.constant.property.value.css

  percentage:
    - include: func-calc
    - match: '(?x)
        (?:
          ({{number}})({{percentage_unit}})\b|
          ({{zero}})
        )'
      captures:
        1: constant.numeric.css
        2: keyword.other.unit.css
        3: constant.numeric.css

  properties:
    - include: property-deprecated
    # TODO: sort properties in reverse alphabetical order
    - include: property-align-content
    - include: property-align-items
    - include: property-alignment-baseline
    - include: property-all
    - include: property-animation-delay
    - include: property-animation-direction
    - include: property-animation-duration
    - include: property-animation-fill-mode
    - include: property-animation-iteration-count
    - include: property-animation-name
    - include: property-animation-play-state
    - include: property-animation-timing-function

    # TODO: add rules for matching property/value pairs here
    - include: property-custom

  # align-content is defined in two specs:
  #     CSS Box Alignment Module Level 3
  #     CSS Flexible Box Layout Module Level 1 (subset of Box Alignment Level 3)
  property-align-content:
    - match: \b(align-content)\s*(:)
      captures:
        1: support.constant.property-name.css
        2: punctuation.separator.key-value.css
      push:
        - include: end-value
        - match: '\bnormal{{b}}'
          scope: support.constant.property-value.css
        - include: baseline-position
        - include: content-distribution
        - include: overflow-position
        - include: content-position

  # align-items is defined in two specs:
  #     CSS Box Alignment Module Level 3
  #     CSS Flexible Box Layout Module Level 1 (subset of Box Alignment Level 3)
  property-align-items:
    - match: \b(align-items)\s*(:)
      captures:
        1: support.constant.property-name.css
        2: punctuation.separator.key-value.css
      push:
        - include: end-value
        - include: value-css-wide
        - match: '\b(?:stretch|normal){{b}}'
          scope: support.constant.property-value.css
        - include: baseline-position
        - include: overflow-position
        - include: self-position

  # align-self is defined in two specs:
  #     CSS Box Alignment Module Level 3
  #     CSS Flexible Box Layout Module Level 1 (subset of Box Alignment Level 3)
  property-align-self:
    - match: \b(align-self)\s*(:)
      captures:
        1: support.constant.property-name.css
        2: punctuation.separator.key-value.css
      push:
        - include: end-value
        - include: value-css-wide
        - match: '\b(?:stretch|normal|auto){{b}}'
          scope: support.constant.property-value.css
        - include: baseline-position
        - include: overflow-position
        - include: self-position

  # CSS Inline Layout Module Level 3
  property-alignment-baseline:
    - match: \b(alignment-baseline)\s*(:)
      captures:
        1: support.constant.property-name.css
        2: punctuation.separator.key-value.css
      push:
        - include: end-value
        - include: value-css-wide
        - match: '(?x)
            \b
            (?:
              top|
              text-top|
              text-bottom|
              middle|
              mathematical|
              ideographic|
              central|
              center|
              bottom|
              baseline|
              alphabetic
            )
            {{b}}'
          scope: support.constant.property.value.css

  # CSS Cascading and Inheritance Level 4
  property-all:
    - match: \b(all)\s*(:)
      captures:
        1: support.constant.property-name.css
        2: punctuation.separator.key-value.css
      push:
        - include: end-value
        - include: value-css-wide

  # TODO: write this
  # property-animation:
  #   - match: \b(animation)\s*(:)
  #     captures:
  #       1: support.constant.property-name.css
  #       2: punctuation.separator.key-value.css
  #     push:
  #       - include: end-value
  #       -

  # CSS Animations Level 1
  property-animation-delay:
    - match: \b(animation-delay)\s*(:)
      captures:
        1: support.constant.property-name.css
        2: punctuation.separator.key-value.css
      push:
        - include: end-value
        - include: value-css-wide
        - include: time

  # CSS Animations Level 1
  property-animation-direction:
    - match: \b(animation-direction)\s*(:)
      captures:
        1: support.constant.property-name.css
        2: punctuation.separator.key-value.css
      push:
        - include: end-value
        - include: value-css-wide
        - include: single-animation-direction

  # CSS Animations Level 1
  property-animation-duration:
    - match: \b(animation-duration)\s*(:)
      captures:
        1: support.constant.property-name.css
        2: punctuation.separator.key-value.css
      push:
        - include: end-value
        - include: value-css-wide
        - include: time

  # CSS Animations Level 1
  property-animation-fill-mode:
    - match: \b(animation-fill-mode)\s*(:)
      captures:
        1: support.constant.property-name.css
        2: punctuation.separator.key-value.css
      push:
        - include: end-value
        - include: value-css-wide
        - include: single-animation-fill-mode

  # CSS Animations Level 1
  property-animation-iteration-count:
    - match: \b(animation-iteration-count)\s*(:)
      captures:
        1: support.constant.property-name.css
        2: punctuation.separator.key-value.css
      push:
        - include: end-value
        - include: value-css-wide
        - include: single-animation-iteration-count

  # CSS Animations Level 1
  property-animation-name:
    - match: \b(animation-name)\s*(:)
      captures:
        1: support.constant.property-name.css
        2: punctuation.separator.key-value.css
      push:
        - include: end-value
        - include: value-css-wide
        - include: single-animation-name

  # CSS Animations Level 1
  property-animation-play-state:
    - match: \b(animation-play-state)\s*(:)
      captures:
        1: support.constant.property-name.css
        2: punctuation.separator.key-value.css
      push:
        - include: end-value
        - include: value-css-wide
        - include: single-animation-play-state

  # CSS Animations Level 1
  property-animation-timing-function:
    - match: \b(animation-timing-function)\s*(:)
      captures:
        1: support.constant.property-name.css
        2: punctuation.separator.key-value.css
      push:
        - include: end-value
        - include: value-css-wide
        - include: single-timing-function

  property-custom:
    - match: '({{custom_property_name}})\s*(:)'
      captures:
        1: support.constant.property-name.custom.css
        2: punctuation.separator.key-value.css
      push:
        - include: end-value
        - include: any-value

  property-deprecated:
    - match: '(?x)
        \b
        {{optional_vendor_prefix}}
        (?:
          zoom|
          wrap-padding|
          wrap-option|
          wrap-margin|
          wrap|
          word-break-inside|
          word-break-cjk|
          white-space-treatment|
          white-space-collapsing|
          white-space-collapse|
          voice-pitch-range|
          vertical-position|
          user-zoom|
          user-modify|
          user-input|
          user-focus|
          text-underline-width|
          text-underline-style|
          text-underline-mode|
          text-underline-color|
          text-underline|
          text-trim|
          text-script|
          text-replace|
          text-overline-width|
          text-overline-style|
          text-overline-mode|
          text-overline-color|
          text-overline|
          text-overflow-mode|
          text-overflow-ellipsis|
          text-outline|
          text-line-through-width|
          text-line-through-style|
          text-line-through-mode|
          text-line-through-color|
          text-line-through|
          text-kashida-space|
          text-justify-trim|
          text-first-indent|
          text-emphasis-skip|
          text-combine-mode|
          text-combine-horizontal|
          text-combine|
          text-block-indent|
          text-blink|
          text-autospace|
          text-align-first|
          target-position|
          target-new|
          target-name|
          target|
          tab-side|
          speakability|
          scroll-snap-points-y|
          scroll-snap-points-x|
          scroll-snap-destination|
          scroll-snap-coordinate|
          row-gap|
          resolution|
          resizer|
          rendering-intent|
          region-overflow|
          punctuation-trim|
          progress-appearance|
          phonemes|
          page-policy|
          overflow-clip|
          orientation|
          nav-index|
          move-to|
          min-zoom|
          min-font-size|
          max-zoom|
          max-font-size|
          mask-source-type|
          mask-box-width|
          mask-box-source|
          mask-box-slice|
          mask-box-repeat|
          mask-box-outset|
          mask-box-image-width|
          mask-box-image-source|
          mask-box-image-slice|
          mask-box-image-repeat|
          mask-box-image-outset|
          mask-box-image|
          mask-box|
          marquee-repetition|
          marquee-play-count|
          marquee|
          marks|
          mark-before|
          mark-after|
          mark|
          linefeed-treatment|
          line-slack|
          line-grid-progression|
          line-grid-mode|
          layout-flow|
          key-equivalent|
          kerning-pair-threshold|
          kerning-mode|
          interpolation-mode|
          indent-edge-reset|
          ime-mode|
          icon|
          hyphenate-resource|
          hyphenate-lines|
          hyphenate-limit-before|
          hyphenate-limit-after|
          hyphenate-dictionary|
          hyphenate-before|
          hyphenate-after|
          hyphenate|
          grid-start|
          grid-span|
          grid-rows|
          grid-row-span|
          grid-row-sizing|
          grid-row-position|
          grid-row-align|
          grid-position|
          grid-flow|
          grid-end|
          grid-definition-rows|
          grid-definition-columns|
          grid-columns|
          grid-column-span|
          grid-column-sizing|
          grid-column-position|
          grid-column-align|
          grid-cell-stacking|
          grid-cell|
          grid-before|
          grid-auto-position|
          grid-after|
          glyph-orientation-horizontal|
          font-smooth|
          float-displace|
          flex-pack|
          flex-order|
          flex-line-pack|
          flex-item-align|
          flex-align|
          fit-position|
          fit|
          filter-margin-top|
          filter-margin-right|
          filter-margin-left|
          filter-margin-bottom|
          filter-margin|
          enable-background|
          display-role|
          display-outside|
          display-model|
          display-list|
          display-inside|
          display-extras|
          display-box|
          crop|
          content-order|
          column-break-before|
          column-break-after|
          color-profile|
          clip|
          clear-after|
          box-width|
          box-reflect|
          box-pack|
          box-orient|
          box-ordinal-group|
          box-lines|
          box-height|
          box-flex-group|
          box-flex|
          box-direction|
          box-break|
          box-align|
          border-length|
          border-break|
          bookmark-target|
          block-progression|
          bleed|
          binding|
          bikeshedding|
          behavior|
          background-spacing|
          background-quantity|
          background-break|
          all-space-treatment|
          accelerator
        )
        {{b}}'  # "clip" won't match "clip-path"
      scope: support.constant.property-name.css invalid.deprecated.css

  # property-list matches a block of property-value pairs.
  # {
  #     property1: value1;
  #     property2: value2;
  # }
  property-list:
    - match: '{'
      scope: punctuation.section.property-list.begin.css
      push:
        - meta_scope: meta.property-list.css
        - match: '(?=})'
          pop: true
        - include: properties

  prototype:
    - include: comment

  ratio:
    - match: '{{ratio}}'
      captures:
        1: constant.numeric.css
        2: keyword.operator.arithmetic.css
        3: constant.numeric.css

  resolution:
    - match: '({{integer_pos}})({{resolution_unit}})'
      captures:
        1: constant.numeric.css
        2: keyword.other.unit.css

  # A rule is a selector and a property list.
  # selector {
  #     property1: value1;
  #     property2: value2;
  # }
  rule:
    - match: '(?=[\w.:#-\[*])'
      push:
        - match: '}'
          scope: punctuation.section.property-list.end.css
          pop: true
        - include: property-list
        - include: selector
    - include: stray-brace

  selector:
    - include: selector-simple-compound
    - include: selector-combinator

  selector-attribute:
    - match: '\['
      scope: punctuation.section.attribute-selector.begin.css
      push:
        - meta_scope: meta.attribute-selector.css
        - match: '\]'
          scope: punctuation.section.attribute-selector.end.css
          pop: true
        # It's difficult to match attribute names and values separately when
        # the values are unquoted.
        #     [attr="value"]  easy to distinguish attr and value
        #     [attr=value]    attr pattern will probably match value text
        # The only way to distinguish the two is that values are always preceded
        # by "attribute matchers" (e.g. ~=, ^=, $=, *=, =). Since we can't use
        # lookbehind to check for this, instead we scan for the matcher first.
        # We push a new context on the stack when we find it. The new context
        # will only match text on the right side of the '=' symbol (the value
        # text). In this way we can fake positive lookbehind.
        - match: '{{attr_matcher}}'
          scope: keyword.operator.attribute-selector.css
          push:
            - match: '(?=])'
              pop: true
            - include: string
            - match: '\b[iI]{{b}}'
              scope: support.constant.attr-modifier.css
            - match: '({{identifier}})\s*(?=[i\]])'
              captures:
                1: string.unquoted.attribute-value.css
        - match: '{{wq_name}}'
          captures:
            1: entity.other.attribute-name.namespace.css
            2: entity.other.attribute-name.namespace.wildcard.css
            3: punctuation.separator.namespace.css
            4: entity.other.attribute-name.css
            5: entity.other.attribute-name.wildcard.css

  selector-class:
    - match: '(\.){{identifier}}'
      captures:
        0: entity.other.attribute-name.class.css
        1: punctuation.definition.entity.css

  selector-combinator:
    - match: '{{combinator}}(?![>+~|])'
      scope: keyword.operator.combinator.css
    - match: '{{combinator}}{2,}'
      scope: keyword.operator.combinator.css invalid.illegal.combinator.css

  selector-id:
    - match: '(#){{identifier}}'
      captures:
        0: entity.other.attribute-name.id.css
        1: punctuation.definition.entity.css

  selector-pseudo-class:
    # Match pseudo-class functions first to avoid collisions between
    # pseudo-classes like :drop and :drop().
    - include: selector-pseudo-class-func
    - include: selector-pseudo-class-deprecated
    - match: '(?x)
      (:)
      {{optional_vendor_prefix}}
      (?:
        visited|
        valid|
        user-invalid|
        target|
        scope|
        root|
        required|
        read-write|
        read-only|
        playing|
        placeholder-shown|
        paused|
        past|
        out-of-range|
        optional|
        only-of-type|
        only-child|
        link|
        last-of-type|
        last-child|
        invalid|
        indeterminate|
        in-range|
        hover|
        host|
        future|
        focus-within|
        focus|
        first-of-type|
        first-child|
        enabled|
        empty|
        drop|
        disabled|
        default|
        current|
        checked|
        blank|
        any-link|
        active
      )
      {{b}}'
      captures:
        0: entity.other.attribute-name.pseudo-class.css
        1: punctuation.definition.entity.css
    - include: selector-pseudo-class-invalid

  selector-pseudo-class-deprecated:
    - match: '(?x)
        (:)
        {{optional_vendor_prefix}}
        (?:
          first-line|
          first-letter|
          bound-element|
          before|
          after
        )
        {{b}}'
      captures:
        0: entity.other.attribute-name.pseudo-class.css invalid.deprecated.css
        1: punctuation.definition.entity.css

  selector-pseudo-class-func:
    - include: selector-pseudo-class-dir
    - include: selector-pseudo-class-drop
    - include: selector-pseudo-class-host
    - include: selector-pseudo-class-lang
    - include: selector-pseudo-class-not-matches-has
    - include: selector-pseudo-class-nth-child
    - include: selector-pseudo-class-nth-column-nth-type
    - include: selector-pseudo-class-scope-context

  selector-pseudo-class-dir:
    - match: ((:)dir)(\()
      captures:
        1: entity.other.attribute-name.pseudo-class.css
        2: punctuation.definition.entity.css
        3: punctuation.section.function.begin.css
      push:
        - meta_content_scope: meta.pseudo-class.dir.css
        - include: end-func
        - match: \b(?:rtl|ltr)\b
          scope: support.constant.property-value.css
    - include: stray-paren

  selector-pseudo-class-drop:
    - match: ((:)drop)(\()
      captures:
        1: entity.other.attribute-name.pseudo-class.css
        2: punctuation.definition.entity.css
        3: punctuation.section.function.begin.css
      push:
        - meta_content_scope: meta.pseudo-class.drop.css
        - include: end-func
        - match: \b(?:valid|invalid|active)\b
          scope: support.constant.property-value.css
    - include: stray-paren

  selector-pseudo-class-host:
    - match: ((:)host(?:-context)?)(\()
      captures:
        1: entity.other.attribute-name.pseudo-class.css
        2: punctuation.definition.entity.css
        3: punctuation.section.function.begin.css
      push:
        - meta_content_scope: meta.pseudo-class.host.css
        - include: end-func
        - include: selector-simple-compound
    - include: stray-paren

  # Match selector text that starts with ":" but isn't on the list of valid
  # pseudo-classes. This prevents the text from being mistakenly matched by
  # another rule, like the type selector.
  selector-pseudo-class-invalid:
    - match: '(:)[\w-]+'
      captures:
        # Don't apply a scope to the whole match so it won't be highlighted.
        1: punctuation.definition.entity.css

  selector-pseudo-class-lang:
    - match: ((:)lang)(\()
      captures:
        1: entity.other.attribute-name.pseudo-class.css
        2: punctuation.definition.entity.css
        3: punctuation.section.function.begin.css
      push:
        - meta_content_scope: meta.pseudo-class.lang.css
        - include: end-func
        - match: '[*a-zA-Z0-9-]+'
          scope: support.constant.property.value.css
    - include: stray-paren

  selector-pseudo-class-not-matches-has:
    - match: '((:)(?:not|matches|has))(\()'
      captures:
        1: entity.other.attribute-name.pseudo-class.css
        2: punctuation.definition.entity.css
        3: punctuation.section.function.begin.css
      push:
        - meta_content_scope: meta.pseudo-class.not-matches-has.css
        - include: end-func
        - include: selector
    - include: stray-paren

  selector-pseudo-class-nth-child:
    - match: '((:)(?:nth-last-child|nth-child))(\()'
      captures:
        1: entity.other.attribute-name.pseudo-class.css
        2: punctuation.definition.entity.css
        3: punctuation.section.function.begin.css
      push:
        - meta_content_scope: meta.pseudo-class.nth-child.css
        - include: end-func
        - match: '\bof{{b}}'
          scope: support.constant.property-value.css
        - include: an_plus_b
        - include: selector
    - include: stray-paren

  selector-pseudo-class-nth-column-nth-type:
    - match: '(?x)
      (
        (:)
        (?:
          nth-of-type|
          nth-last-of-type|
          nth-last-column|
          nth-column
        )
      )
      (\()'
      captures:
        1: entity.other.attribute-name.pseudo-class.css
        2: punctuation.definition.entity.css
        3: punctuation.section.function.begin.css
      push:
        - meta_content_scope: meta.pseudo-class.nth.css
        - include: end-func
        - include: an_plus_b
    - include: stray-paren

  selector-pseudo-class-scope-context:
    - match: ((:)scope-context)(\()
      captures:
        1: entity.other.attribute-name.pseudo-class.css
        2: punctuation.definition.entity.css
        3: punctuation.section.function.begin.css
      push:
        - meta_content_scope: meta.pseudo-class.scope-context.css
        - include: end-func
        - include: selector
    - include: stray-paren

  selector-pseudo-element:
    - match: '(?x)
        (::)
        {{optional_vendor_prefix}}
        (?:
          spelling-error|
          shadow|
          selection|
          region|
          placeholder|
          marker|
          inactive-selection|
          grammar-error|
          first-line|
          first-letter|
          content|
          before|
          after
        )
        {{b}}'
      captures:
        0: entity.other.attribute-name.pseudo-element.css
        1: punctuation.definition.entity.css
    - include: selector-pseudo-element-slotted
    - include: selector-pseudo-element-attr
    - include: selector-pseudo-element-invalid

  selector-pseudo-element-attr:
    - match: '((::)attr)(\()'
      captures:
        1: entity.other.attribute-name.pseudo-element.css
        2: punctuation.definition.entity.css
        3: punctuation.section.function.begin.css
      push:
        - meta_content_scope: meta.pseudo-element.attr.css
        - include: end-func
        # The <wq-name> pattern is close enough to the <namespace-attr> pattern
        # defined in Non-element Selectors Module Level 1.
        # https://drafts.csswg.org/selectors-nonelement/#attribute-node-selectors
        - match: '{{wq_name}}'
          captures:
            1: string.unquoted.namespace.css
            2: string.unquoted.namespace.wildcard.css
            3: punctuation.separator.namespace.css
            4: entity.name.tag.css
            5: entity.name.tag.wildcard.css
    - include: stray-paren

  # Match selector text that starts with "::" but isn't on the list of valid
  # pseudo-elements. This prevents the text from being mistakenly matched by
  # another rule, like the type selector.
  selector-pseudo-element-invalid:
    - match: '(::)[\w-]+'
      captures:
        # Don't apply a scope to the whole match so it won't be highlighted.
        1: punctuation.definition.entity.css

  selector-pseudo-element-slotted:
    - match: '((::)slotted)(\()'
      captures:
        1: entity.other.attribute-name.pseudo-element.css
        2: punctuation.definition.entity.css
        3: punctuation.section.function.begin.css
      push:
        - meta_content_scope: meta.pseudo-element.slotted.css
        - include: end-func
        - include: selector-simple-compound
    - include: stray-paren

  # This matches simple selectors and compound selectors, which are just one
  # or more simple selectors.
  selector-simple-compound:
    - include: selector-pseudo-element
    - include: selector-pseudo-class
    - include: selector-id
    - include: selector-class
    - include: selector-attribute
    # Match selector-type last because this includes custom elements, which
    # match nonspecific identifiers.
    - include: selector-type

  selector-type:
    - include: selector-type-deprecated
    - match: '(?x)
        (?:
          {{wq_name}}|
          {{ns_prefix}}(\*)
        )'
      captures:
        1: string.unquoted.namespace.css
        2: string.unquoted.namespace.wildcard.css
        3: punctuation.separator.namespace.css
        4: entity.name.tag.css
        5: entity.name.tag.wildcard.css
        6: string.unquoted.namespace.css
        7: string.unquoted.namespace.wildcard.css
        8: punctuation.separator.namespace.css
        9: entity.name.tag.wildcard.css

  selector-type-deprecated:
    - match: '(?x)
        \b
        (?:
          xmp|
          tt|
          strike|
          spacer|
          plaintext|
          noframes|
          noembed|
          nobr|
          nextid|
          multicol|
          marquee|
          listing|
          isindex|
          hgroup|
          frameset|
          frame|
          font|
          dir|
          center|
          blink|
          big|
          bgsound|
          basefont|
          applet|
          acronym
        )
        {{b}}'
      scope: entity.name.tag.css invalid.deprecated.css

  self-position:
    - match: '(?x)
        \b
        (?:
          start|
          self-start|
          self-end|
          right|
          left|
          flex-start|
          flex-end|
          end|
          center
        )
        {{b}}'
      scope: support.constant.property.value.css

  single-animation-direction:
    - match: '(?x)
        \b
        (?:
          reverse|
          normal|
          alternate-reverse|
          alternate
        )
        {{b}}'
      scope: support.constant.property-value.css

  single-animation-fill-mode:
    - match: '(?x)
        \b
        (?:
          none|
          forwards|
          both|
          backwards
        )
        {{b}}'
      scope: support.constant.property-value.css

  single-animation-iteration-count:
    - match: '\binfinite{{b}}'
      scope: support.constant.property-value.css
    - include: number

  single-animation-name:
    - match: '\bnone{{b}}'
      scope: support.constant.property-value.css
    - include: string
    - include: identifier

  single-animation-play-state:
    - match: '\b(?:running|paused){{b}}'
      scope: support.constant.property-value.css

  single-timing-function:
    - match: '(?x)
        \b
        (?:
          step-start|
          step-end|
          linear|
          ease-out|
          ease-in-out|
          ease-in|
          ease
        )
        {{b}}
      '
      scope: support.constant.property-value.css
    - include: func-cubic-bezier
    - include: func-steps

  stray-brace:
    - match: '}'
      scope: invalid.illegal.stray-brace.css

  stray-paren:
    - match: \)
      scope: invalid.illegal.stray-paren.css

  string:
    - include: string-double
    - include: string-single

  string-double:
    - match: '"'
      scope: punctuation.definition.string.begin.css
      push:
        # /* inside string should not match as comment
        - meta_include_prototype: false
        - meta_scope: string.quoted.double.css
        - match: '"'
          scope: punctuation.definition.string.end.css
          pop: true
        - include: escape

  string-single:
    - meta_include_prototype: false
    - match: "'"
      scope: punctuation.definition.string.begin.css
      push:
        # /* inside string should not match as comment
        - meta_include_prototype: false
        - meta_scope: string.quoted.single.css
        - match: "'"
          scope: punctuation.definition.string.end.css
          pop: true
        - include: escape

  time:
    - include: func-calc
    - match: '(?x)
        (?:
          ({{number}})({{time_unit}})\b|
          ({{zero}})
        )'
      captures:
        1: constant.numeric.css
        2: keyword.other.unit.css
        3: constant.numeric.css

  # This context matches CSS-wide keywords and functions, like "inherit" and
  # "var()". It should be included in all property contexts.
  value-css-wide:
    - include: func-var
    # TODO: write these? they are at-risk.
    # - include: func-attr
    # - include: func-toggle
    - match: '\b(?:unset|revert|inherit|initial){{b}}'
      scope: support.constant.property-value.css
